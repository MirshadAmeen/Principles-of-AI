def knapsack(weights, values, capacity):
    n = len(values)
    
    # Create a 2D list to store the maximum value that can be achieved
    # with the first i items and a knapsack capacity of j
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
    
    # Build dp table in bottom-up manner
    for i in range(1, n + 1):
        for j in range(1, capacity + 1):
            if weights[i - 1] <= j:
                dp[i][j] = max(dp[i - 1][j], values[i - 1] + dp[i - 1][j - weights[i - 1]])
            else:
                dp[i][j] = dp[i - 1][j]
    
    # The maximum value will be found in dp[n][capacity]
    max_value = dp[n][capacity]
    
    # To find the items included in the knapsack, backtrack through dp table
    chosen_items = []
    w = capacity
    for i in range(n, 0, -1):
        if max_value <= 0:
            break
        if max_value == dp[i - 1][w]:
            continue
        else:
            chosen_items.append(i - 1)
            max_value -= values[i - 1]
            w -= weights[i - 1]
    
    chosen_items.reverse()
    return dp[n][capacity], chosen_items

# Example usage:
weights = [10, 20, 30]
values = [60, 100, 120]
capacity = 50

max_value, items = knapsack(weights, values, capacity)
print(f"Maximum value that can be achieved: {max_value}")
print(f"Items included in the knapsack (0-indexed): {items}")
